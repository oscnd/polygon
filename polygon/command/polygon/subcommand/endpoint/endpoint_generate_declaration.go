package endpoint

import (
	"fmt"
	"log"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/lithammer/dedent"
)

// GenerateDeclaration generates the Go swagger declarations file
func (g *Generator) GenerateDeclaration() error {
	log.Printf("generating declaration.go...")

	// Create output directory
	outputDir := filepath.Join("generate", "swagger")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	outputPath := filepath.Join(outputDir, "declaration.go")
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write package declaration and imports
	_, _ = file.WriteString("package swagger\n\n")
	_, _ = file.WriteString("import (\n")
	_, _ = file.WriteString("\t_ \"backend/type/payload\"\n")
	_, _ = file.WriteString("\t_ \"go.scnd.dev/open/polygon/compat/response\"\n")
	_, _ = file.WriteString(")\n\n")

	// Write file header comment
	_, _ = file.WriteString("// Code generated by polygon endpoint subcommand. DO NOT EDIT.\n")
	_, _ = file.WriteString(fmt.Sprintf("// Generated at: %s\n\n", time.Now().Format(time.RFC3339)))

	// Write swagger annotations for each endpoint
	for _, endpoint := range g.Endpoints {
		swaggerComment := g.generateSwaggerComment(endpoint)
		_, _ = file.WriteString(swaggerComment)
		_, _ = file.WriteString("\n")
	}

	log.Printf("generated %d endpoint declarations", len(g.Endpoints))
	return nil
}

// generateSwaggerComment generates Swagger annotation comments for an endpoint
func (g *Generator) generateSwaggerComment(endpoint EndpointInfo) string {
	// Generate ID from endpoint name
	id := strings.TrimPrefix(endpoint.Name, "Handle")
	id = strings.ToLower(id[:1]) + id[1:]

	// Build swagger parameters
	params := g.buildSwaggerParameters(endpoint)

	// Generate router path
	routerPath := g.generateRouterPath(endpoint)

	return fmt.Sprintf(dedent.Dedent(`
			// %s
			// @ID %s
			// @Tags %s%s
			// @Success 200 {object} %s
			// @Failure 400 {object} %s
			// @Router %s [%s]
			func %s() {
				_ = 0
			}
		`),
		endpoint.Name,
		id,
		endpoint.Tag,
		params,
		g.getReturnType(endpoint),
		endpoint.ErrorType,
		routerPath,
		endpoint.Method,
		endpoint.Name,
	)
}

// buildSwaggerParameters builds swagger parameter annotations
func (g *Generator) buildSwaggerParameters(endpoint EndpointInfo) string {
	var params strings.Builder

	// Add query parameters
	if endpoint.QueryType != "" {
		params.WriteString(fmt.Sprintf("\n// @Param query query %s true \"Query\"", endpoint.QueryType))
	}

	// Add body parameters
	if endpoint.BodyType != "" {
		params.WriteString(fmt.Sprintf("\n// @Param body body %s true \"Body\"", endpoint.BodyType))
	}

	// Add form parameters when c.Bind().Form() is detected
	if endpoint.FormType != "" {
		// Generate consumes annotation for multipart form
		params.WriteString("\n// @Accept multipart/form-data")

		// Add form parameter for the entire form struct
		params.WriteString(fmt.Sprintf("\n// @Param form formData %s true \"Form\"", endpoint.FormType))

		// Add individual form fields if available
		if len(endpoint.FormFields) > 0 {
			for _, field := range endpoint.FormFields {
				required := "true"
				if !field.Required {
					required = "false"
				}

				// Handle field type properly - use []file for []*multipart.FileHeader
				fieldType := "formData"
				swaggerType := field.Type
				if field.IsFile {
					fieldType = "formData"
					// Check if it's an array of files by looking at the original form type
					if strings.Contains(endpoint.FormType, "[]*multipart.FileHeader") {
						swaggerType = "[]file"
					} else {
						swaggerType = "file"
					}
				}

				params.WriteString(fmt.Sprintf("\n// @Param %s %s %s %s \"%s\"",
					field.Name, fieldType, swaggerType, required, field.Name))
			}
		}
	}

	// Add default accepts if no form is detected
	if endpoint.FormType == "" && (endpoint.BodyType != "" || endpoint.QueryType != "") {
		params.WriteString("\n// @Accept json")
	}

	// Add default produces
	params.WriteString("\n// @Produce json")

	return params.String()
}

// generateRouterPath generates the router path using url.JoinPath logic
func (g *Generator) generateRouterPath(endpoint EndpointInfo) string {
	// Parse the current path
	currentPath := strings.TrimPrefix(endpoint.Path, "/")
	pathParts := strings.Split(currentPath, "/")

	// Build path components: ["api", group, ...pathParts]
	var pathComponents []string
	pathComponents = append(pathComponents, "api")

	// Add group if present
	if len(pathParts) > 0 && pathParts[0] != "" {
		pathComponents = append(pathComponents, pathParts[0])
		// Add remaining path parts if they exist
		if len(pathParts) > 1 {
			pathComponents = append(pathComponents, pathParts[1:]...)
		}
	}

	// Use url.JoinPath to construct the path
	finalPath, err := url.JoinPath("/", pathComponents...)
	if err != nil {
		// Fallback to manual construction if url.JoinPath fails
		finalPath = "/" + strings.Join(pathComponents, "/")
	}

	return finalPath
}

// getReturnType returns the appropriate response type
func (g *Generator) getReturnType(endpoint EndpointInfo) string {
	if endpoint.ReturnType != "" {
		return endpoint.ReturnType
	}
	return "response.SuccessResponse" // default
}

// ParseStructFields parses struct fields for form generation
func (g *Generator) ParseStructFields(structType string) ([]*FormField, error) {
	// This is a placeholder for struct field parsing
	// In a real implementation, you would:
	// 1. Use go/types to resolve the struct type
	// 2. Parse the struct fields
	// 3. Extract field information including tags for required/file detection

	// For now, return empty slice
	return []*FormField{}, nil
}

// GenerateSwaggerFromStruct generates form fields from a struct type
func (g *Generator) GenerateFormFieldsFromStruct(structName string) ([]*FormField, error) {
	// This would use reflection or AST parsing to extract struct fields
	// Implementation depends on whether you have access to the compiled types
	// or need to parse source files

	// Placeholder implementation
	return []*FormField{}, nil
}
